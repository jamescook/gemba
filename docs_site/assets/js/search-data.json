{
  "0": {
    "title": "Gemba",
    "type": "module",
    "url": "/api/Gemba/",
    "methods": "load_locale user_config user_config=",
    "method_docs": {
      "load_locale": "Load translations based on the config locale setting.",
      "user_config": "Lazily loaded user config — shared across the application.",
      "user_config=": "Override the user config (useful for tests)."
    },
    "content": "Gemba Load translations based on the config locale setting. Lazily loaded user config — shared across the application. Override the user config (useful for tests)."
  },
  "1": {
    "title": "Gemba::CLI",
    "type": "class",
    "url": "/api/Gemba/CLI/",
    "methods": "apply parse parse_decode parse_record run",
    "method_docs": {
      "apply": "Apply parsed CLI options to the user config (session-only overrides).",
      "parse": "Parse player (default) command options.",
      "parse_decode": "--- decode subcommand ---",
      "parse_record": "--- record subcommand ---",
      "run": "Entry point: dispatch to subcommand or player."
    },
    "content": "Gemba CLI Apply parsed CLI options to the user config (session-only overrides). Parse player (default) command options. --- decode subcommand --- --- record subcommand --- Entry point: dispatch to subcommand or player."
  },
  "2": {
    "title": "Gemba::ChildWindow",
    "type": "module",
    "url": "/api/Gemba/ChildWindow/",
    "methods": "build_toplevel hide_window position_near_parent show_window",
    "method_docs": {
      "build_toplevel": "Create and configure a toplevel window with standard boilerplate.\nHides the window at the end — call show_window to reve",
      "hide_window": "Withdraw the window, release grab if modal, fire on_close callback.",
      "position_near_parent": "Position this window to the right of the main application window.",
      "show_window": "Reveal the window, optionally grabbing focus (modal)."
    },
    "content": "Gemba ChildWindow Shared helpers for child windows (Settings, Save State Picker, ROM Info). Including classes must define a TOP constant and an @app instance variable. Modal windows (grab focus) use show_window/hide_window. Non-modal windows (like ROM Info) use show_window(modal: false)/hide_window(modal: false). Create and configure a toplevel window with standard boilerplate. Hides the window at the end — call show_window to reveal it. Withdraw the window, release grab if modal, fire on_close "
  },
  "3": {
    "title": "Gemba::Config",
    "type": "class",
    "url": "/api/Gemba/Config/",
    "methods": "config_dir default_path default_recordings_dir default_saves_dir default_screenshots_dir default_states_dir game_config_path reset! rom_id activate_game add_recent_rom clear_recent_roms color_correction= color_correction? deactivate_game dead_zone disable_per_game enable_per_game frame_blending= frame_blending? gamepad hotkeys initialize integer_scale= integer_scale? keep_aspect_ratio= keep_aspect_ratio? locale locale= mappings muted= muted? per_game_settings= per_game_settings? pixel_filter pixel_filter= quick_save_slot quick_save_slot= recent_roms recording_compression recording_compression= recordings_dir recordings_dir= reload! remove_recent_rom reset_gamepad reset_hotkeys rewind_enabled= rewind_enabled? rewind_seconds rewind_seconds= save! save_state_backup= save_state_backup? save_state_debounce save_state_debounce= saves_dir saves_dir= scale scale= set_dead_zone set_hotkey set_mapping show_fps= show_fps? states_dir states_dir= tip_dismiss_ms tip_dismiss_ms= toast_duration toast_duration= turbo_speed turbo_speed= turbo_volume_pct turbo_volume_pct= volume volume=",
    "method_docs": {
      "default_path": "-- Platform paths ----------------------------------------------------",
      "reset!": "Delete the settings file at the given path (or the default).",
      "rom_id": "Build a ROM identifier from game code and CRC32 checksum.\nUses the same sanitization as SaveStateManager#state_dir_for_r",
      "activate_game": "Activate per-game config for the given ROM. If per_game_settings? is\ntrue, reads/writes to PER_GAME_KEYS will go through",
      "add_recent_rom": "Add a ROM path to the front of the recent list (deduplicates).",
      "deactivate_game": "Deactivate per-game settings (e.g. when ROM is unloaded).",
      "disable_per_game": "Disable per-game settings. Reverts to global values.\nDoes NOT delete the game-specific file on disk.",
      "enable_per_game": "Enable per-game settings for the currently loaded ROM.\nCopies current global values to game file on first enable.",
      "remove_recent_rom": "Remove a specific ROM path from the recent list.",
      "save!": "-- Persistence -------------------------------------------------------",
      "scale": "-- Global settings ---------------------------------------------------"
    },
    "content": "Gemba Config Persists mGBA Player settings to a JSON file in the platform-appropriate config directory. Config file location: macOS: ~/Library/Application Support/gemba/settings.json Linux: $XDG_CONFIG_HOME/gemba/settings.json (~/.config/gemba/) Windows: %APPDATA%/gemba/settings.json Gamepad mappings are keyed by SDL GUID (identifies controller model/type), so different controller types keep separate configs. Per-game settings: when enabled, a subset of settings (video, audio, save state) can be"
  },
  "4": {
    "title": "Gemba::Config::PerGameProxy",
    "type": "class",
    "url": "/api/Gemba/Config/PerGameProxy/",
    "methods": "[] []= initialize",
    "method_docs": {},
    "content": "Gemba Config PerGameProxy Transparent proxy that routes per-game keys to a game-specific hash and everything else to the base (global) hash. Config getters/setters call global['key'] — this intercepts those calls so no other code needs to know whether per-game settings are active."
  },
  "5": {
    "title": "Gemba::Core",
    "type": "class",
    "url": "/api/Gemba/Core/",
    "methods": "audio_buffer checksum destroy destroyed? game_code height initialize load_state_from_file maker_code platform rom_size run_frame save_state_to_file set_keys title video_buffer video_buffer_argb width",
    "method_docs": {
      "audio_buffer": "Drain the audio output for the most recent frame(s).\nReturns interleaved stereo signed 16-bit PCM samples (L R L R ...).",
      "checksum": "CRC32 checksum of the loaded ROM.",
      "destroy": "Shut down the emulator core and free all resources.\nFurther method calls will raise.",
      "destroyed?": "Whether the core has been destroyed.",
      "game_code": "Game code from the ROM header, prefixed with platform\n(e.g. \"AGB-BTKE\" for GBA, \"CGB-XXXX\" for GBC).",
      "height": "Video output height in pixels (160 for GBA).",
      "initialize": "Load a GBA ROM and initialize the emulator core.\nDetects the platform (GBA/GB/GBC) from the file extension,\nallocates vi",
      "load_state_from_file": "Restore emulator state from a previously saved state file.",
      "maker_code": "2-character maker/publisher code from the GBA ROM header\nat offset 0xB0 (e.g. \"01\" for Nintendo).\nReturns empty string f",
      "platform": "Platform string: \"GBA\", \"GB\", or \"Unknown\".",
      "rom_size": "Size of the loaded ROM in bytes.",
      "run_frame": "Advance the emulation by one video frame (~16.7 ms of GBA time).\nReleases the GVL so other Ruby threads can run during e",
      "save_state_to_file": "Save the complete emulator state (CPU, memory, audio, video) to a file.\nIncludes battery save data and RTC state.",
      "set_keys": "Set the currently pressed buttons as a bitmask.\nCombine key constants with bitwise OR:\n  +core.set_keys(Gemba::KEY_A | G",
      "title": "Internal ROM title (up to 12 characters for GBA).",
      "video_buffer": "Raw pixel data for the current frame.\nReturns a binary String of +width * height * 4+ bytes in mGBA's\nnative color forma",
      "video_buffer_argb": "Pixel data converted to ARGB8888 for SDL2 textures.\nSame dimensions as {#video_buffer} but with R and B channels\nswapped",
      "width": "Video output width in pixels (240 for GBA)."
    },
    "content": "Gemba Core GBA emulator core wrapping libmgba's mCore API. Core loads a GBA ROM, emulates one frame at a time, and provides access to the video and audio output buffers. Pair with {Teek::SDL2::Renderer} for display and {Teek::SDL2::AudioStream} for sound. Drain the audio output for the most recent frame(s). Returns interleaved stereo signed 16-bit PCM samples (L R L R ...). The number of samples varies per frame (~548 at 32768 Hz). CRC32 checksum of the loaded ROM. Shut down the emulator core an"
  },
  "6": {
    "title": "Gemba::GamepadMap",
    "type": "class",
    "url": "/api/Gemba/GamepadMap/",
    "methods": "dead_zone_pct initialize labels load_config mask reload! reset! save_to_config set set_dead_zone supports_deadzone?",
    "method_docs": {},
    "content": "Gemba GamepadMap Manages SDL gamepad button → GBA bitmask mappings. Shares the same interface as {KeyboardMap} so that Player can delegate to either without knowing which device type is active."
  },
  "7": {
    "title": "Gemba::HeadlessPlayer",
    "type": "class",
    "url": "/api/Gemba/HeadlessPlayer/",
    "methods": "open audio_buffer checksum close closed? game_code height initialize load_state maker_code platform press recording? release_all rewind_count rewind_deinit rewind_init rewind_pop rewind_push rom_size save_state start_recording step stop_recording title video_buffer_argb width",
    "method_docs": {
      "open": "Open a HeadlessPlayer, yield it, and close when done.",
      "close": "Shut down the core and free resources.",
      "press": "Set currently pressed buttons as a bitmask.\nUse KEY_* constants: `player.press(KEY_A | KEY_START)`",
      "release_all": "Release all buttons.",
      "start_recording": "Start recording video + audio to a .grec file.",
      "step": "Run one or more frames. Captures to recorder if recording.",
      "stop_recording": "Stop recording and finalize the file."
    },
    "content": "Gemba HeadlessPlayer Headless mGBA player for scripting and automated testing. Wraps Core with a simple API — no Tk, no SDL2, no event loop. Open a HeadlessPlayer, yield it, and close when done. Shut down the core and free resources. Set currently pressed buttons as a bitmask. Use KEY_* constants: `player.press(KEY_A | KEY_START)` Release all buttons. Start recording video + audio to a .grec file. Run one or more frames. Captures to recorder if recording. Stop recording and finalize the file."
  },
  "8": {
    "title": "Gemba::HotkeyMap",
    "type": "class",
    "url": "/api/Gemba/HotkeyMap/",
    "methods": "display_name modifier_key? modifiers_from_state normalize normalize_keysym normalize_modifier action_for initialize key_for labels load_config reload! reset! save_to_config set",
    "method_docs": {
      "display_name": "Human-readable display name for a hotkey.",
      "modifiers_from_state": "Extract active modifier names from a Tk event state bitmask.",
      "normalize": "Normalize a hotkey: sort modifiers canonically.",
      "normalize_keysym": "Normalize variant Tk keysyms to their canonical form.\nHandles: ISO_Left_Tab → Tab, Shift+letter uppercase → lowercase,\nS",
      "normalize_modifier": "Normalize a Tk modifier keysym (e.g. \"Control_L\" → \"Control\").",
      "action_for": "Look up which action matches a keysym + active modifiers.",
      "load_config": "Load hotkeys from config. Falls back to defaults for missing keys.",
      "reload!": "Re-read config from disk, then reload bindings.",
      "reset!": "Restore all bindings to defaults.",
      "save_to_config": "Write current hotkeys to config (does not call save!).",
      "set": "Rebind an action to a new hotkey. Clears any existing action\nusing the same hotkey to prevent conflicts."
    },
    "content": "Gemba HotkeyMap Maps player actions (quit, pause, etc.) to keyboard hotkeys. A hotkey is either a plain keysym String (\"F5\") or an Array of modifier(s) + key ([\"Control\", \"s\"]). Provides reverse lookup for efficient dispatch in the input loop. Human-readable display name for a hotkey. Extract active modifier names from a Tk event state bitmask. Normalize a hotkey: sort modifiers canonically. Normalize variant Tk keysyms to their canonical form. Handles: ISO_Left_Tab → Tab, Shift+letter uppercase"
  },
  "9": {
    "title": "Gemba::KeyboardMap",
    "type": "class",
    "url": "/api/Gemba/KeyboardMap/",
    "methods": "dead_zone_pct initialize labels load_config mask reload! reset! save_to_config set set_dead_zone supports_deadzone?",
    "method_docs": {},
    "content": "Gemba KeyboardMap Manages keyboard keysym → GBA bitmask mappings. Shares the same interface as {GamepadMap} so that Player can delegate to either without knowing which device type is active."
  },
  "10": {
    "title": "Gemba::Locale",
    "type": "module",
    "url": "/api/Gemba/Locale/",
    "methods": "available_languages language load translate",
    "method_docs": {
      "load": "Load translations for the given language code.\nFalls back to English if the requested locale file doesn't exist.",
      "translate": "Look up a translation by dot-separated key, with optional variable\ninterpolation. Returns the key itself if no translati"
    },
    "content": "Gemba Locale Lightweight YAML-backed localization. No external gem dependencies. Load translations for the given language code. Falls back to English if the requested locale file doesn't exist. Look up a translation by dot-separated key, with optional variable interpolation. Returns the key itself if no translation is found."
  },
  "11": {
    "title": "Gemba::Locale::Translatable",
    "type": "module",
    "url": "/api/Gemba/Locale/Translatable/",
    "methods": "",
    "method_docs": {},
    "content": "Gemba Locale Translatable Mixin for classes that need translation access. Include this to call `translate` / `t` as instance methods."
  },
  "12": {
    "title": "Gemba::OverlayRenderer",
    "type": "class",
    "url": "/api/Gemba/OverlayRenderer/",
    "methods": "destroy draw ff_visible? fps_visible? initialize set_ff_label set_fps",
    "method_docs": {
      "destroy": "Free all textures.",
      "draw": "Draw all active overlays.\n\nFPS is positioned top-right; FF label is positioned top-left.\nBoth are inset from the game ar",
      "ff_visible?": "Whether the fast-forward label is currently showing.",
      "fps_visible?": "Whether the FPS overlay is currently showing.",
      "set_ff_label": "Update the fast-forward indicator label. Pass nil to hide.",
      "set_fps": "Update the FPS counter text. Pass nil to hide."
    },
    "content": "Gemba OverlayRenderer Renders inverse-blend HUD overlays (FPS counter, fast-forward indicator) on top of the game viewport. White source pixels invert the destination, so the text is always readable regardless of the game's background color. Transparent regions pass through unchanged. Free all textures. Draw all active overlays. FPS is positioned top-right; FF label is positioned top-left. Both are inset from the game area defined by +dest+. Whether the fast-forward label is currently showing. W"
  },
  "13": {
    "title": "Gemba::Player",
    "type": "class",
    "url": "/api/Gemba/Player/",
    "methods": "apply_fade_ramp initialize muted? recording? run",
    "method_docs": {
      "apply_fade_ramp": "Apply a linear fade-in ramp to int16 stereo PCM data.\nPure function: takes remaining/total counters, returns [pcm, new_r"
    },
    "content": "Gemba Player Full-featured GBA player with SDL2 video/audio rendering, keyboard and gamepad input, save states, and recording. Apply a linear fade-in ramp to int16 stereo PCM data. Pure function: takes remaining/total counters, returns [pcm, new_remaining]."
  },
  "14": {
    "title": "Gemba::Recorder",
    "type": "class",
    "url": "/api/Gemba/Recorder/",
    "methods": "capture frame_count initialize recording? start stop",
    "method_docs": {
      "capture": "Capture one frame of video + audio.",
      "start": "Start recording. Writes header and spawns writer thread.",
      "stop": "Stop recording. Flushes remaining data, writes footer, closes file."
    },
    "content": "Gemba Recorder Records emulator video + audio to a .grec file. Video is delta-compressed (XOR with previous frame) then zlib level 1. Audio is stored as raw PCM. A background thread handles disk I/O so the frame loop stays fast. Capture one frame of video + audio. Start recording. Writes header and spawns writer thread. Stop recording. Flushes remaining data, writes footer, closes file."
  },
  "15": {
    "title": "Gemba::RecorderDecoder",
    "type": "class",
    "url": "/api/Gemba/RecorderDecoder/",
    "methods": "decode stats decode initialize stats",
    "method_docs": {
      "decode": "Decode a .grec file and encode to a playable video file.",
      "stats": "Quick stats scan — reads only header + 1 byte per frame."
    },
    "content": "Gemba RecorderDecoder Decodes a .grec file and encodes it to a playable video via ffmpeg. Two-pass approach to avoid writing massive intermediate files: Pass 1: Extract audio to a small tempfile (~10MB/min), count frames, collect per-frame change percentages. Pass 2: Decode video frames one at a time and pipe to ffmpeg's stdin. Only one decoded video frame is in memory at a time, so RAM usage stays constant regardless of recording length. Decode a .grec file and encode to a playable video file. "
  },
  "16": {
    "title": "Gemba::RecorderDecoder::FfmpegNotFound",
    "type": "class",
    "url": "/api/Gemba/RecorderDecoder/FfmpegNotFound/",
    "methods": "",
    "method_docs": {},
    "content": "Gemba RecorderDecoder FfmpegNotFound"
  },
  "17": {
    "title": "Gemba::RecorderDecoder::FormatError",
    "type": "class",
    "url": "/api/Gemba/RecorderDecoder/FormatError/",
    "methods": "",
    "method_docs": {},
    "content": "Gemba RecorderDecoder FormatError"
  },
  "18": {
    "title": "Gemba::RomInfoWindow",
    "type": "class",
    "url": "/api/Gemba/RomInfoWindow/",
    "methods": "publisher_name hide initialize show",
    "method_docs": {
      "publisher_name": "Look up a publisher name from a 2-char maker code.",
      "show": "Show the ROM Info window, populating it with data from the given core."
    },
    "content": "Gemba RomInfoWindow Displays ROM metadata in a read-only window. Shown via View > ROM Info when a ROM is loaded. Contains a two-column grid of labels: field name on the left, value on the right. Look up a publisher name from a 2-char maker code. Show the ROM Info window, populating it with data from the given core."
  },
  "19": {
    "title": "Gemba::RomLoader",
    "type": "class",
    "url": "/api/Gemba/RomLoader/",
    "methods": "cleanup_temp resolve tmp_dir",
    "method_docs": {
      "cleanup_temp": "Remove previously extracted temp files.",
      "resolve": "Resolve a path to a loadable ROM file.\nFor ROM files, returns the path unchanged.\nFor ZIP files, extracts the single ROM"
    },
    "content": "Gemba RomLoader Resolves ROM paths for the player. Handles both bare ROM files and .zip archives containing a single ROM at the zip root. Remove previously extracted temp files. Resolve a path to a loadable ROM file. For ROM files, returns the path unchanged. For ZIP files, extracts the single ROM inside to a temp directory."
  },
  "20": {
    "title": "Gemba::RomLoader::Error",
    "type": "class",
    "url": "/api/Gemba/RomLoader/Error/",
    "methods": "",
    "method_docs": {},
    "content": "Gemba RomLoader Error"
  },
  "21": {
    "title": "Gemba::RomLoader::MultipleRomsInZip",
    "type": "class",
    "url": "/api/Gemba/RomLoader/MultipleRomsInZip/",
    "methods": "",
    "method_docs": {},
    "content": "Gemba RomLoader MultipleRomsInZip"
  },
  "22": {
    "title": "Gemba::RomLoader::NoRomInZip",
    "type": "class",
    "url": "/api/Gemba/RomLoader/NoRomInZip/",
    "methods": "",
    "method_docs": {},
    "content": "Gemba RomLoader NoRomInZip"
  },
  "23": {
    "title": "Gemba::RomLoader::UnsupportedFormat",
    "type": "class",
    "url": "/api/Gemba/RomLoader/UnsupportedFormat/",
    "methods": "",
    "method_docs": {},
    "content": "Gemba RomLoader UnsupportedFormat"
  },
  "24": {
    "title": "Gemba::RomLoader::ZipReadError",
    "type": "class",
    "url": "/api/Gemba/RomLoader/ZipReadError/",
    "methods": "",
    "method_docs": {},
    "content": "Gemba RomLoader ZipReadError"
  },
  "25": {
    "title": "Gemba::SaveStateManager",
    "type": "class",
    "url": "/api/Gemba/SaveStateManager/",
    "methods": "initialize load_state quick_load quick_save save_screenshot save_state screenshot_path state_dir_for_rom state_path",
    "method_docs": {
      "load_state": "Load the emulator state from the given slot.",
      "quick_load": "Load from the quick save slot.",
      "quick_save": "Save to the quick save slot.",
      "save_screenshot": "Save a PNG screenshot of the current frame via Tk photo image.\nUses @app.command() to drive Tk's image subsystem.",
      "save_state": "Save the emulator state to the given slot.",
      "state_dir_for_rom": "Build per-ROM state directory path using game code + CRC32.\ne.g. states/AGB-BTKE-A1B2C3D4/"
    },
    "content": "Gemba SaveStateManager Manages save state persistence: save, load, screenshot capture, debounce, and backup rotation. All dependencies are injected via the constructor so the class can be tested with lightweight mocks (no real mGBA Core or Tk interpreter). Load the emulator state from the given slot. Load from the quick save slot. Save to the quick save slot. Save a PNG screenshot of the current frame via Tk photo image. Uses @app.command() to drive Tk's image subsystem. Save the emulator state "
  },
  "26": {
    "title": "Gemba::SaveStatePicker",
    "type": "class",
    "url": "/api/Gemba/SaveStatePicker/",
    "methods": "hide initialize show",
    "method_docs": {},
    "content": "Gemba SaveStatePicker Grid picker window for save state slots. Displays up to 10 slots in a 2×5 grid. Each cell shows a PNG thumbnail screenshot, the slot number, and the save timestamp — or an \"Empty\" placeholder. Left-click a populated slot to load, click an empty slot to save. The current quick-save slot is highlighted with a distinct border. Uses native Tk photo images for thumbnails (loaded via `image create photo -file`). Pure Tk — no SDL2."
  },
  "27": {
    "title": "Gemba::SettingsWindow",
    "type": "class",
    "url": "/api/Gemba/SettingsWindow/",
    "methods": "capture_hk_mapping capture_mapping finalize_hk hide initialize keyboard_mode? mark_dirty refresh_gamepad refresh_hotkeys set_per_game_active set_per_game_available show update_gamepad_list",
    "method_docs": {
      "capture_hk_mapping": "Capture a hotkey during listen mode. Called by the Tk <Key>\nbind script, or directly by tests.\n\nModifier keys (Ctrl, Shi",
      "finalize_hk": "Finalize a captured hotkey (plain key or combo). Also called by\ntests that want to bypass the modifier settle timer.",
      "mark_dirty": "Enable the Save button (called when any setting changes)",
      "refresh_gamepad": "Refresh the gamepad tab widgets from external state (e.g. after undo).",
      "refresh_hotkeys": "Refresh the hotkeys tab widgets from external state (e.g. after undo).",
      "set_per_game_active": "Sync the per-game checkbox to the current config state.",
      "set_per_game_available": "Enable/disable the per-game checkbox (called when ROM loads/unloads)."
    },
    "content": "Gemba SettingsWindow Settings window for the mGBA Player. Opens a Toplevel with a ttk::notebook containing Video, Audio, and Gamepad tabs. Closing the window hides it (withdraw) rather than destroying it. Widget paths and Tcl variable names are exposed as constants so tests can interact with the UI the same way a user would (set variable, generate event, assert result). Capture a hotkey during listen mode. Called by the Tk <Key> bind script, or directly by tests. Modifier keys (Ctrl, Shift, Alt)"
  },
  "28": {
    "title": "Gemba::TipService",
    "type": "class",
    "url": "/api/Gemba/TipService/",
    "methods": "hide initialize register show showing?",
    "method_docs": {
      "hide": "Hide the current tooltip.",
      "register": "Register a widget for click-to-show tooltip.",
      "show": "Show a tooltip below the given widget. Hides any existing tip first."
    },
    "content": "Gemba TipService Click-to-show tooltip service for Tk widgets. Labels registered with {#register} get an underlined font (like HTML <abbr>). Clicking them shows a tooltip popup below the label. Only one tooltip is visible at a time; it auto-dismisses after {#dismiss_ms} unless the mouse hovers over the tip or its label. The tooltip is rendered as a frame inside the parent window (not a toplevel), so it draws as a true rectangle on all platforms. Hide the current tooltip. Register a widget for cl"
  },
  "29": {
    "title": "Gemba::ToastOverlay",
    "type": "class",
    "url": "/api/Gemba/ToastOverlay/",
    "methods": "destroy draw initialize show visible?",
    "method_docs": {
      "destroy": "Remove the current toast and free textures.",
      "draw": "Draw the toast centered at the bottom of the game area.",
      "show": "Display a toast message. Replaces any existing toast.",
      "visible?": "Whether a toast is currently visible."
    },
    "content": "Gemba ToastOverlay Renders timed notification toasts at the bottom of the game viewport. One toast at a time; showing a new one replaces the old. The background is a pre-rendered anti-aliased rounded rectangle (generated in C). All SDL2 objects (renderer, font, textures) are injected or created internally, so the class can be tested with lightweight mocks. Remove the current toast and free textures. Draw the toast centered at the bottom of the game area. Display a toast message. Replaces any exi"
  },
  "30": {
    "title": "Gemba::VirtualKeyboard",
    "type": "class",
    "url": "/api/Gemba/VirtualKeyboard/",
    "methods": "button? closed? initialize press release",
    "method_docs": {},
    "content": "Gemba VirtualKeyboard Virtual keyboard device that tracks key press/release state. Presents the same interface as an SDL gamepad: +button?+ and +closed?+."
  }
}